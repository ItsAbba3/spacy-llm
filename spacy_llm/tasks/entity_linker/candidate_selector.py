import warnings
from pathlib import Path
from typing import Iterable, Optional, Union

from spacy import Vocab
from spacy.kb import InMemoryLookupKB
from spacy.pipeline import EntityLinker
from spacy.tokens import Span

from .ty import EntDescReader, Entity
from .util import UNAVAILABLE_ENTITY_DESC, InMemoryLookupKBLoader


class PipelineCandidateSelector:
    """Callable generated by loading and wrapping a spaCy pipeline with an EL component and a filled knowledge base."""

    def __init__(
        self,
        kb_loader: InMemoryLookupKBLoader,
        desc_path: Optional[Union[Path, str]],
        top_n: int,
        ent_desc_reader: EntDescReader,
    ):
        """Generates CandidateSelector. Note that this class has to be initialized (.initialize()) before being used.
        kb_loader (InMemoryLookupKBLoader): KB loader.
        desc_path (Optional[Union[Path, str]]): Path to .csv file with descriptions for entities. Has to have two
            columns with the first one being the entity ID, the second one being the description. The entity ID has to
            match with the entity ID in the stored knowledge base.
            If not specified, all entity descriptions provided in prompts will be a generic "No description available"
            or something else to this effect.
        el_component_name (str): EL component name.
        top_n (int): Top n candidates to include in prompt.
        ent_desc_reader (EntDescReader): Entity description reader.
        """
        self._kb_loader = kb_loader
        self._kb: Optional[InMemoryLookupKB] = None
        self._descs = ent_desc_reader(desc_path) if desc_path else {}
        self._top_n = top_n

    def initialize(self, vocab: Vocab) -> None:
        """Initialize instance with vocabulary.
        vocab (Vocab): Vocabulary.
        """
        self._kb = self._kb_loader(vocab)

    def __call__(self, mentions: Iterable[Span]) -> Iterable[Iterable[Entity]]:
        """Retrieves top n candidates using spaCy's entity linker's .get_candidates_batch().
        mentions (Iterable[Span]): Mentions to look up entity candidates for.
        RETURNS (Iterable[Iterable[Entity]]): Top n entity candidates per mention.
        """
        if self._kb is None:
            raise ValueError("CandidateSelector has to be initialized before usage.")

        all_cands = self._kb.get_candidates_batch(mentions)
        for cands in all_cands:
            assert isinstance(cands, list)
            cands.sort(key=lambda x: x.prior_prob, reverse=True)

        return [
            [
                Entity(
                    id=cand.entity_,
                    description=self.get_entity_description(cand.entity_),
                )
                for cand in cands[: self._top_n]
            ]
            if len(cands) > 0
            else [Entity(id=EntityLinker.NIL, description=UNAVAILABLE_ENTITY_DESC)]
            for cands in all_cands
        ]

    def get_entity_description(self, entity_id: str) -> str:
        """Returns entity description for entity ID. If none found, a warning is emitted and
            spacy_llm.tasks.enttiy_linker.util.UNAVAILABLE_ENTITY_DESC is returned.
        entity_id (str): Entity whose ID should be looked up.
        RETURNS (str): Entity description for entity with specfied ID. If no description found, returned string equals
            spacy_llm.tasks.enttiy_linker.util.UNAVAILABLE_ENTITY_DESC.
        """
        if entity_id not in self._descs:
            warnings.warn(
                f"Entity with ID {entity_id} is not in provided descriptions."
            )

        return self._descs.get(entity_id, UNAVAILABLE_ENTITY_DESC)
