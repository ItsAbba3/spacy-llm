from pathlib import Path
from typing import Optional, Type, Union

from spacy.scorer import Scorer

from ...registry import registry
from ...ty import ExamplesConfigType, FewshotExample, TaskResponseParser
from .parser import parse_responses_v1
from .task import DEFAULT_EL_TEMPLATE_V1, EntityLinkerTask
from .util import EntLinkExample, SpaCyPipelineCandidateSelector, score


@registry.llm_tasks("spacy.EntityLinker.v1")
def make_entitylinker_task(
    template: str = DEFAULT_EL_TEMPLATE_V1,
    parse_responses: Optional[TaskResponseParser[EntityLinkerTask]] = None,
    prompt_example_type: Optional[Type[FewshotExample]] = None,
    examples: ExamplesConfigType = None,
    scorer: Optional[Scorer] = None,
):
    """EntityLinking.v1 task factory.

    template (str): Prompt template passed to the model.
    parse_responses (Optional[TaskResponseParser]): Callable for parsing LLM responses for this task.
    prompt_example_type (Optional[Type[FewshotExample]]): Type to use for fewshot examples.
    examples (ExamplesConfigType): Optional callable that reads a file containing task examples for few-shot learning.
        If None is passed, then zero-shot learning will be used.
    """
    raw_examples = examples() if callable(examples) else examples
    example_type = prompt_example_type or EntLinkExample
    examples = [example_type(**eg) for eg in raw_examples] if raw_examples else None
    # Ensure there is a reason for every solution, even if it's empty. This makes templating easier.
    if examples:
        for example in examples:
            if example.reasons is None:
                example.reasons = [""] * len(example.solutions)
            elif len(example.reasons) < len(example.solutions):
                example.reasons.extend(
                    [""] * (len(example.solutions) - len(example.reasons))
                )

    return EntityLinkerTask(
        template=template,
        parse_responses=parse_responses or parse_responses_v1,
        prompt_example_type=example_type,
        prompt_examples=examples,
        scorer=scorer or score,
    )


@registry.llm_misc("spacy.CandidateSelector.v1")
def make_candidate_selector_pipeline(
    nlp_path: Union[Path, str],
    desc_path: Union[Path, str],
    top_n: int = 5,
) -> SpaCyPipelineCandidateSelector:
    """Instantiates Callable generated by loading and wrapping a spaCy pipeline with an EL component and a filled
    knowledge base.
    top_n (int): Top n candidates to include in prompt.
    nlp_path (Union[Path, str]): Path to stored spaCy pipeline.
    desc_path (Union[Path, str]): Path to .csv file with descriptions for entities. Has to have two columns
      with the first one being the entity ID, the second one being the description. The entity ID has to match with
      the entity ID in the stored knowledge base.
    """
    # Note: we could also move the class implementation here directly. This was just done to separate registration from
    # implementation code.
    return SpaCyPipelineCandidateSelector(
        nlp_path=nlp_path, desc_path=desc_path, top_n=top_n
    )
